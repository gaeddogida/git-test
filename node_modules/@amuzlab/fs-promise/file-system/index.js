'use strict'

const fs = require('fs'),
    path = require('path'),
    readline = require('readline'),
    os = require('os'),
    utility = require('@amuzlab/utils'),
    action = require('./action-util'),
    watcher = require('./watcher'),
    errCtl = require('./errCtl'),
    ThrottleStream = require('./ThrottleStream.js'),

    EOL_REGEXP = /(?:\n|\r\n|\r)/g


/**
 * @module      file-system
 * @desc        amuzlab file system module
 * @since       0.0.1
*/

require('graceful-fs').gracefulify(fs)

function _getTimeDiff (date1, date2) {
    return Math.floor(utility.date.dateCompareTo(date1, date2, utility.date.CRITERIA.SECONDS));
}

Object.defineProperties(
    exports,
    {
        fs: {
            enumerable: true,
            value: fs
        },
        checkPath: {
            enumerable: true,
            value: (filePath) => new Promise((resolve, reject) => {
                filePath = utility.path.normalizePath(filePath, __dirname)

                fs.stat(
                    filePath,
                    (err, stat) => {
                        if (err) {
                            reject(errCtl(err))
                        } else {
                            resolve({
                                filePath : filePath,
                                stat: stat
                            })
                        }
                    })
            })
        },
        copyFile: {
            enumerable: true,
            value: (source, destination, options) => {
                return Promise.all([
                    exports.checkPath(source),
                    exports.checkPath(path.dirname(destination))
                    .catch(err => exports.mkdir(path.dirname(destination)))
                ])
                    .then(result => new Promise((resolve, reject) => {
                        const sourceFileInfo = result.shift(),
                            destinationDirInfo = result.shift()

                        destination = path.resolve(destinationDirInfo.filePath, destination)
                        let size = 0,
                            startTime = new Date(),
                            beforeTime = 0,
                            isError = false

                        const readStream = fs.createReadStream(sourceFileInfo.filePath)
                            .on('open', () => action.callListener(options, 'readFileOpen', {
                                filePath: sourceFileInfo.filePath,
                                stat: sourceFileInfo.stat
                            }))
                            // .on('end', () => writeStream.end())
                            .on('data', chunk => {
                                size += chunk.length
                                let _time = _getTimeDiff(new Date(), startTime),
                                    _progress

                                if (size == 0 || size == sourceFileInfo.stat.size || (beforeTime < _time)) {
                                    _progress = {
                                        fileName: path.basename(source),
                                        chunk: chunk,
                                        percentAge: size / sourceFileInfo.stat.size * 100,
                                        size: size,
                                        maxSize: sourceFileInfo.stat.size,
                                        time: _time,
                                        startTime: startTime,
                                        speed: _time >= 1 ? size / _time : size
                                    }

                                    action.callListener(options, 'data', _progress)

                                    beforeTime = _time
                                }
                            })
                            .on('error', err => {
                                isError = true
                                readStream.close()
                                err = errCtl(err)
                                action.callListener(options, 'error', err)
                                reject(err)
                            })

                        const writeStream = fs.createWriteStream(destination)
                            .on('open', () => action.callListener(options, 'writeFileOpen', destination))
                            .on('pipe', source => action.callListener(options, 'startCopyFile', {
                                source: source,
                                fileName: path.basename(source.path),
                                maxSize: sourceFileInfo.stat.size
                            }))
                            .on('close', () => {
                                let endTime, _time, result;
                                isError ? null : (
                                    endTime = new Date(),
                                    _time = _getTimeDiff(endTime, startTime),
                                    result = {
                                        source: sourceFileInfo.filePath,
                                        fileName: path.basename(source),
                                        destination: destination,
                                        time: _time,
                                        size: size,
                                        totalSize: sourceFileInfo.stat.size,
                                        percentAge: size / sourceFileInfo.stat.size * 100,
                                        speed: _time >= 1 ? size / _time : size,
                                        startTime: startTime,
                                        endTime: endTime
                                    },
                                    action.callListener(options, 'end', result),
                                    resolve(result));
                            })
                            .on('error', err => (
                                err = errCtl(err),
                                action.callListener(options, 'error', err),
                                reject(err)))
                        if (options && options.maxCopyBandwidth) {
                            const throttle = new ThrottleStream({ maxCopyBandwidth: options && options.maxCopyBandwidth })
                            throttle
                                .on('end', () => writeStream.end())
                                .on('error', err => {
                                    isError = true
                                    throttle.end()
                                    err = errCtl(err)
                                    action.callListener(options, 'error', err)
                                    reject(err)
                                })
                            readStream.pipe(throttle).pipe(writeStream);
                        } else readStream.pipe(writeStream)
                        // readStream.pipe(writeStream);
                    }));
            }
        },
        copyFiles: {
            enumerable: true,
            value: (files, options) => {
                return new Promise((resolve, reject) => {
                    let i, result;
                    files ? (
                        i = 0,
                        result = {
                            startTime: new Date(),
                            time: 0,
                            files: [],
                            totalSize: 0,
                            size: 0,
                            currentCount: 0,
                            totalCount: files.length,
                            fileNames: Array.from(files, _file => path.basename(_file.source))
                        },
            
                        Promise.all(Array.from(files, _file => exports.checkPath(_file.source)))
                        .then(results => (
                            result.totalSize = results.reduce((totalSize, result) => totalSize + result.stat.size, 0),
                            action.callListener(options, 'startCopyFiles', {
                                totalSize: result.totalSize,
                                startTime: result.startTime,
                                time: result.time,
                                files: Array.from(
                                    files,
                                    (_file, _index) => Object.assign(
                                        {},
                                        _file,
                                        {size: results[_index].stat.size}))})))
                        .then(() => (function _copyFile(file){
                            file ? (
                                result.currentCount++,
                                exports.copyFile(
                                    file.source,
                                    file.destination,
                                    Object.assign(
                                        {},
                                        options,
                                        {
                                            end: null,
                                            data: data => (
                                                result.time = _getTimeDiff(new Date(), result.startTime),
                                                result.percentAge = (result.size + data.size) / result.totalSize * 100,
                                                result.speed = data.speed,
                                                action.callListener(options, 'data', {
                                                    current: data,
                                                    total: Object.assign(
                                                        {},
                                                        result,
                                                        {size: result.size + data.size})}))}))
                                .then(_result => (
                                    result.size += _result.size,
                                    result.percentAge = result.size / result.totalSize,
                                    result.files.push(_result),
            
                                    action.callListener(options, 'end', Object.assign(_result, {
                                        percentAge: result.percentAge,
                                        currentCount: result.currentCount,
                                        totalCount: result.totalCount
                                    })),
            
                                    _copyFile(files[i++])))
                                .catch(err => reject(err))) : (
                                    result.endTime = new Date(),
                                    result.time = _getTimeDiff(result.endTime, result.startTime),
                                    result.percentAge = result.size / result.totalSize * 100,
                                    resolve(result));
                        })(files[i++]))
                        .catch(err => reject(err))) : reject(new Error('files is undefined or null.'));
                });
            }
        },
        /**
         * @name        copyDir
         * @desc        디렉터리 복사
         * @function
         * @async
         * @static
         * @public
         * @param       {String}        source          복사 대상 디렉터리
         * @param       {String}        destination     복사 위치
         * @param       {Object}        options       디렉터리 복사중 이벤트 처리 listener 및 복사 옵션
         * @since       1.0.5
         * @date        2020-06-08
        */
        copyDir: {
            enumerable: true,
            value: async (source, destination, options) => {
                let files = [],  // { source, destination }
                    err,
                    sourceCheckPathResult = await exports.checkPath(source)

                if (sourceCheckPathResult.stat.isDirectory()) {
                    await (async function readdir (dirPath) {
                        let result = await exports.readdir(dirPath),
                            dirs = []

                        await Promise.all(result.files.map(file => {
                            const filePath = path.join(result.path, file)

                            return exports.checkPath(filePath)
                                .then(result => {
                                    result.stat.isDirectory() ? dirs.push(filePath) : files.push({
                                        source: filePath,
                                        destination: path.join(destination, path.relative(source, filePath))
                                    })
                                })
                        }))

                        return await Promise.all(dirs.map(dirPath => readdir(dirPath)))
                    })(source)

                    return await exports.copyFiles(files, options)
                } else {
                    err = new Error(`source is not directory (${source})`)
                    err.source = source
                    throw err
                }
            }
        },
        mkdir: {
            enumerable: true,
            value: (dirPath) => {
                return exports.checkPath(path.dirname(dirPath))
                    .catch(err => {
                        err = errCtl(err);
                        if(err.code == 'E102'){
                            return exports.mkdir(path.dirname(dirPath));
                        }else{
                            throw err;
                        }
                    })
                    .then(result =>
                        new Promise((resolve, reject) =>
                            fs.stat(dirPath, (err, stat) =>
                                err ? (
                                    err = errCtl(err),
                                    err.code == 'E102' ? fs.mkdir(
                                        dirPath,
                                        err => !err ? resolve(dirPath) : (
                                            err = errCtl(err),
                                            err.code === 'E101' ? resolve(dirPath) : reject(err))) : (err.code === 'E101' ? resolve(dirPath) : reject(err)))
                                : resolve(dirPath))));
            }
        },
        readdir: {
            enumerable: true,
            value: (dirPath) => {
                return exports.checkPath(path.dirname(dirPath))
                    .then(result => new Promise((resolve, reject) => {
                        fs.readdir(
                            dirPath,
                            (err, files) => err ? reject(errCtl(err)) : resolve({
                                path: dirPath,
                                files: files
                            }))
                    }));
            }
        },
        rmdir: {
            enumerable: true,
            value: (dirPath) => {
                return exports.readdir(dirPath)
                    .then(result => Promise.all(
                        result.files.map(_path => new Promise((resolve, reject) => {
                            let _subPath = path.join(result.path, _path);
                            fs.stat(
                                _subPath,
                                (err, stat) => stat && stat.isDirectory() ? resolve(exports.rmdir(_subPath)) : fs.unlink(_subPath, err => !err ? resolve() : reject(errCtl(err))));
                        }))))
                    .then(result =>
                        new Promise((resolve, reject) => fs.rmdir(
                            dirPath,
                            err => !err ? resolve(dirPath) : (
                                err = errCtl(err),
                                err.code === 'E102' ? resolve(dirPath) : reject(err)))));
            }
        },
        readFile: {
            enumerable: true,
            value: (filePath, option) => {
                return exports.checkPath(filePath)
                    .then(() => new Promise((resolve, reject) => (
                        fs.readFile(
                            filePath,
                            option,
                            (err, data) => err ? reject(errCtl(err, filePath)) : resolve({
                                filePath: filePath,
                                data: data
                            })))));
            }
        },
        writeFile: {
            enumerable: true,
            value: (filePath, data, option) => {
                return exports.mkdir(path.dirname(filePath))
                    .then(result =>
                        new Promise((resolve, reject) =>
                            fs.writeFile(
                                filePath,
                                data,
                                option,
                                err => err ? reject(errCtl(err)) : resolve(filePath))))
            }
        },
        overrite: {
            enumerable: true,
            value: (filePath, callback, encoding) => {
                return typeof callback === 'function' ? exports.readFile(filePath, typeof encoding === 'string' ? encoding : null)
                    .then(data => exports.writeFile(filePath, callback(data, filePath))) : Promise.reject(new Error('callback is not a function type.'));
            }
        },
        readLine: {
            enumerable: true,
            value: (filePath, option) => {
                let start = 0, count = 0, result = [], fileLineReader, curLineCount = 0, readStream;
                option && typeof option === 'object' ? (
                    typeof option.start === 'number' && option.start >= 0 ? start = option.start : null,
                    typeof option.count === 'number' && option.count >= 0 ? count = option.count : null) : null;
            
                return exports.checkPath(filePath)
                    .then(() => new Promise((resolve, reject) => (
                    readStream = fs.createReadStream(filePath)
                    .on('close', () => resolve({
                        filePath: filePath,
                        result: result
                    })),
                        fileLineReader = readline.createInterface({
                    input: readStream
                        })
                        .on('line', data => (
                            curLineCount++,
                            result.length < count || !count ? (curLineCount >= start ? result.push(data) : null) : fileLineReader.close()
                        ))
                    .on('close', () => readStream.close())
                        .on('error', err => reject(errCtl(err))))
                    ));
            }
        },
        removeFile: {
            enumerable: true,
            value: filePath => {
                let result = {
                    filePath: filePath,
                    isAlreadyRemoved: false
                }

                return exports.checkPath(filePath)
                    .then(() => {
                        return new Promise((resolve, reject) => {
                            fs.unlink(
                                filePath,
                                err => {
                                    if (err) {
                                        reject(errCtl(err))
                                    } else {
                                        resolve(result)
                                    }
                                })
                        })
                    })
                    .catch(err => {
                        if (err.code === 'E102') {
                            result.isAlreadyRemoved = true
                            return result
                        } else {
                            throw err
                        }
                    })
            }
        },
        removeFiles: {
            enumerable: true,
            value: async (filePaths, listeners) => {
                let index = 0, result = []
                listeners || (listeners = {})

                typeof listeners.start === 'function' && listeners.start(filePaths)

                return await (async function _removeFile (filePath) {
                    if (filePath) {
                        result.push(await exports.removeFile(filePath))
                        index++

                        typeof listeners.progress === 'function' && listeners.progress({ result: result, percentAge: Math.floor(index / filePaths.length * 100) })
                        return await _removeFile(filePaths[index])
                    } else {
                        typeof listeners.end === 'function' && listeners.end(result)
                        return result
                    }
                })(filePaths[index])
            }
        },
        removeLineSync: {
            enumerable: true,
            value: (filePath, target, encoding) => {
                let data, lines, filter, ignores = [], curLineNumber;
            
                try{
                    fs.statSync(filePath);
                    data = fs.readFileSync(filePath, {
                        encoding: typeof encoding === 'string' ? encoding : 'utf8'
                    });
                    return data === '' || (filter = _getFilter(target), typeof filter !== 'function') ? ({
                        filePath: filePath,
                        result: []
                    }) : (
                        lines = data.split(EOL_REGEXP).filter((line, index) => (
                            curLineNumber = index + 1,
                            filter(line, curLineNumber) ? true : (
                                ignores.push({
                                    lineNumber: curLineNumber,
                                    line: line
                                }),
                                false
                            )
                        )),
                        fs.writeFileSync(filePath, lines.join(os.EOL)),
                        {
                            filePath: filePath,
                            result: ignores
                        }
                    )
                }catch(err){
                    throw errCtl(err);
                }
            }
        },
        removeLine: {
            enumerable: true,
            value: (filePath, target) => {
                let fileLineReader, writeStream, fileName, dirPath, tempFilePath, curLineNumber = 0, isRename = true, err, filter, ignores = [];
            
                return exports.checkPath(filePath)
                    .then(() => (filter = _getFilter(target), typeof filter === 'function') ? (
                        fileName = path.basename(filePath),
                        dirPath = path.dirname(filePath),
                        tempFilePath = path.join(dirPath, `${fileName}.tmp`),
                        new Promise((resolve, reject) => (
                            writeStream = fs.createWriteStream(tempFilePath)
                            .on('close', () => isRename ? fs.rename(
                                tempFilePath,
                                filePath,
                                err => err ? reject(errCtl(err)) : resolve({
                                    filePath: filePath,
                                    result: ignores
                                })) : fs.unlink(tempFilePath, _err => reject(errCtl(_err ? _err : err))))
                            .on('error', err => reject(errCtl(err))),
            
                            fileLineReader = readline.createInterface({
                                input: fs.createReadStream(filePath)
                            })
                            .on('line', line => (
                                curLineNumber++,
                                filter(line, curLineNumber) ? writeStream.write(line + os.EOL) : ignores.push({
                                    lineNumber: curLineNumber,
                                    line: line
                                })
                            ))
                            .on('close', () => writeStream.end())
                            .on('error', _err => (
                                isRename = false,
                                writeStream.end(),
                                err = _err))
                        ))) : Promise.resolve({
                            filePath: filePath,
                            result: []
                        }));
            }
        },
        addLine: {
            enumerable: true,
            value: (filePath, line) => {
                return typeof line === 'string' ? exports.checkPath(filePath)
                    .catch(err => {
                        if(err.code !== 'E102'){
                            throw err;
                        }
                    })
                    .then(() => new Promise((resolve, reject) => fs.writeFile(
                        filePath,
                        EOL_REGEXP.test(line) ? line : line + os.EOL,
                        {
                            flag: 'a+'
                        },
                        err => err ? reject(errCtl(err)) : resolve({
                            filePath: filePath,
                            result: line
                        })
                    ))) : Promise.reject(new Error('line이 문자열이 아닙니다.'));
            }
        },
        rename: {
            enumerable: true,
            value: (oldPath, newPath) => {
                return exports.checkPath(oldPath)
                    .then(() => exports.mkdir(path.dirname(newPath))
                        .then(() => new Promise((resolve, reject) => fs.rename(
                            oldPath,
                            newPath,
                            err => err ? reject(errCtl(err)) : resolve({
                                oldPath: oldPath,
                                newPath: newPath})))));
            }
        },
        watch: {
            enumerable: true,
            value: watcher.watch
        },
        closeWatch: {
            enumerable: true,
            value: watcher.closeWatch
        }
    })

function _getFilter (target){
    let filter;

    switch(true){
        case typeof target === 'number':
            filter = (line, curLineNumber) => (target !== curLineNumber);
            break;
        case typeof target === 'string':
            filter = line => (target !== line);
            break;
        case target instanceof RegExp:
            filter = line => !target.test(line);
            break;
        case Array.isArray(target):
            filter = (line, curLineNumber) => !target.some(targetElement => {
                let result;

                switch(true){
                    case typeof targetElement === 'number':
                        result = targetElement === curLineNumber;
                        break;
                    case typeof targetElement === 'string':
                        result = targetElement === line;
                        break;
                    case targetElement instanceof RegExp:
                        result = targetElement.test(line);
                        break;
                }

                return result;
            });
            break;
    }

    return filter;
}
