'use strict'

const path = require('path'),
    fs = require('fs'),

    utils = require('@amuzlab/utils'),

    store = require('./store'),
    Watcher = require('./Watcher'),
    File = require('./File'),
    Directory = require('./Directory'),

    DEFAULT = {
        RECURSIVE: true,
        IGNORE: /(^|[\/\\])\../,
        INIT: false,
        CHECK_INTERVAL: 10          // 브라우저에서는 setTimeout의 최소시간을 4ms로 권고하지만 Node.js에서는 libuv 초고정밀 타이머를 사용하기 때문에 최소 시간이 없음
    }

Object.defineProperties(
    exports,
    {
        watch: {
            enumerable: true,
            value: (targetPath, option, listener) => {
                const watcher = new Watcher(targetPath)

                option || (option = {})
                typeof option.recursive !== 'boolean' && (option.recursive = DEFAULT.RECURSIVE)
                option.ignore instanceof RegExp || (option.ignore = DEFAULT.IGNORE)
                typeof option.init !== 'boolean' && (option.init = DEFAULT.INIT)
                utils.validation.isInt(option.checkInterval) || (option.checkInterval = DEFAULT.CHECK_INTERVAL)

                watcher.addDirectory(new Directory(path.dirname(targetPath), path.basename(targetPath), fs.statSync(targetPath), path.relative(targetPath, targetPath)))

                watcher.addFsWatcher(targetPath, watch(watcher, targetPath, option, listener))

                store.add(watcher)

                return watcher
            }
        },
        closeWatch: {
            enumerable: true,
            value: (targetPath) => {
                targetPath instanceof Watcher && (targetPath = targetPath.targetPath)
                return store.close(targetPath)
            }
        }
    })

function watch (watcher, targetPath, option, listener) {
    let fsWatcher = fs.watch(
        targetPath,
        option,
        (eventType, fileName) => {
            let stat, file, directory, _fsWatcher, fullPath = path.join(targetPath, fileName)

            if (!option.ignore.test(fileName)) {
                switch (eventType) {
                    case 'change':
                        // file change
                        file = watcher.getFile(targetPath, fileName)

                        file && file.change()
                        break
                    case 'rename':
                        // create or remove
                        try {
                            // create
                            stat = fs.statSync(fullPath)

                            if (stat.isDirectory()) {
                                directory = new Directory(targetPath, fileName, stat, path.relative(watcher.targetPath, fullPath))
                                watcher.addDirectory(directory)
                                option && option.recursive && watcher.addFsWatcher(fullPath, watch(watcher, fullPath, option, listener))
                                emitEvent(listener, 'addDirectory', directory)
                            } else {
                                file = new File(targetPath, fileName, stat, path.relative(watcher.targetPath, fullPath), option)
                                    .on('create', file => {
                                        try {
                                            watcher.addFile(file) ? emitEvent(listener, 'addFile', file) : emitEvent(listener, 'changeFile', file)
                                        } catch (err) {
                                            emitEvent(listener, 'error', err, targetPath, fileName, eventType)
                                        }
                                    })
                                    .on('change', file => {
                                        emitEvent(listener, 'changeFile', file)
                                    })

                                file.startCheckCreate()
                            }
                        } catch (err) {
                            // remove or rename
                            switch (err.code) {
                                case 'ENOENT':
                                    directory = watcher.getDirectory(path.join(targetPath, fileName))

                                    if (directory) {
                                        watcher.removeFsWatcher(directory.fullPath)
                                        watcher.removeDirectory(directory.fullPath)
                                        emitEvent(listener, 'removeDirectory', directory)
                                    } else {
                                        // 파일
                                        file = watcher.getFile(targetPath, fileName)

                                        if (file) {
                                            watcher.removeFile(targetPath, fileName)
                                            emitEvent(listener, 'removeFile', file)
                                        }
                                    }

                                    break
                                default:
                                    emitEvent(listener, 'error', err, targetPath, fileName, eventType)
                            }
                        }

                        break
                }
            }
        })

    fsWatcher.targetPath = targetPath

    fs
        .readdirSync(targetPath)
        .forEach(file => {
            let stat, _file, fullPath = path.join(targetPath, file)

            if (!option.ignore.test(file)) {
                stat = fs.statSync(path.join(targetPath, file))

                if (stat.isDirectory()) {
                    _file = new Directory(targetPath, file, stat, path.relative(watcher.targetPath, fullPath))
                    watcher.addDirectory(_file)
                    option.recursive && watcher.addFsWatcher(fullPath, watch(watcher, fullPath, option, listener))
                    option.init && emitEvent(listener, 'addDirectory', _file)
                } else {
                    _file = new File(targetPath, file, stat, path.relative(watcher.targetPath, fullPath), option)
                        .on('change', file => {
                            emitEvent(listener, 'changeFile', file)
                        })

                    watcher.addFile(_file)
                    option.init && emitEvent(listener, 'addFile', _file)
                }
            }
        })

    return fsWatcher
}

function emitEvent (listener, eventName, ...args) {
    listener && typeof listener[eventName] === 'function' && listener[eventName](...args)
}
