'use strict'

/** class definition **/
/**
 * @classdesc       nodejs event 확장 클래스
 * @extends         events.EventEmitter
 * @since           1.2.1
*/

const util = require('./util'),
    validation = require('./validation')

class EventEmitter extends require('events') {
    /**
     * @constructs
    */
    constructor () {
        super()
    }

    /**
     * @name        on
     * @memberof    EventEmitter
     * @function
     * @instance
     * @public
     * @desc        eventName으로 event listener 등록
     * @since       1.2.9
     * @param       {String|Array<Object>}          eventName                   등록할 이벤트명 또는 이벤트 리스너 리스트<br/>
     *                                                                          <ul>
     *                                                                              <li>String : 이벤트명</li>
     *                                                                              <li>Array<Object> : 이벤트 리스너 리스트</li>
     *                                                                          </ul>
     * @param       {String}                        eventName[].eventName       이벤트명
     * @param       {Function|Array<Function>}      eventName[].listener        <ul>
     *                                                                              <li>Function : 이벤트 리스너</li>
     *                                                                              <li>Array<Function> : 이벤트 리스너 리스트</li>
     *                                                                          </ul>
     * @param       {Function|Array<Function>}      [listener]                  <ul>
     *                                                                              <li>Function : 이벤트 리스너</li>
     *                                                                              <li>Array<Function> : 이벤트 리스너 리스트</li>
     *                                                                          </ul>
     *                                                                          eventName이 String 타입인 경우 필수
     * @returns     {EventEmitter}      return this
    */
    on (eventName, listener) {
        let events, listeners

        switch (true) {
            case typeof eventName === 'string':
                events = [ { eventName: eventName, listener: listener } ]
                break
            case Array.isArray(eventName):
                events = eventName
                break
            default:
                throw new TypeError(`eventName type must be of String or Array (eventName : ${eventName})`)
        }

        util.forEach(
            events,
            e => {
                if (e.listener) {
                    listeners = Array.isArray(e.listener) ? e.listener : [ e.listener ]

                    util.forEach(
                        listeners,
                        _listener => typeof _listener === 'function' && super.on(e.eventName, _listener))
                }
            })

        return this
    }

    /**
     * @name        pipe
     * @memberof    EventEmitter
     * @function
     * @instance
     * @public
     * @desc        event 발생 대상으로부터 target으로 이벤트 연결
     * @param       {Object}                    param                                   function parameter
     * @param       {Object}                    param.target                            이벤트 연결 대상
     * @param       {Array<Object>}             param.events                            이벤트 연결 정보
     * @param       {String}                    param.events[].eventName                이벤트명
     * @param       {String}                    [param.events[].targetName]             target 이벤트명<br/>
     *                                                                                  값이 없으면 source 이벤트명 그대로 전달
     * @param       {Function}                  [param.events[].filter]                 filter 설정이 있는 경우, filter의 리턴값이 true인 경우에만 event 발생
     * @param       {Function}                  [param.events[].callback]               target event 호출 후 실행될 callback function
     * @param       {Array<Object>|Function}    [param.events[].mapper]                 target 으로 pipelining할 때, parameter를 remapping하거나 function으로 수정 및 전달 가능<br/>
     *                                                                                  <ul>
     *                                                                                      <li>Function : 함수를 실행시켜 source에서 전달된 parameter를 조작하여 target event로 전달 가능 (Array로 리턴하면 target event에 parameter로 전달)</li>
     *                                                                                      <li>Array<Object> : 세팅 값으로 parameter를 조작하여 target event로 전달 가능</li>
     *                                                                                  </ul>
     * @param       {Integer}                   [param.events[].mapper[].index]         source event에서 전달된 parameter index<br/>
     *                                                                                  index가 없는 경우는 target event로 전달되는 parameters에 추가되어 전달됨<br/>
     *                                                                                  mapper가 Object인 경우 사용
     * @param       {Integer}                   [param.events[].mapper[].targetIndex]   target event로 전달할 때의 parameter index<br/>
     *                                                                                  parameter 개수 부족시, index 가 변경될 수 있음<br/>
     *                                                                                  mapper가 Object인 경우 사용
     * @param       {Function|any}              [param.events[].mapper[].mapper]        source event에서 전달된 parameter를 전달받아 mapper를 실행하고 리턴값을 target event로 전달<br/>
     *                                                                                  mapper.index 값이 없고 mapper가 function 타입이 아니면 target event로 전달되는 paramter 끝에 추가<br/>
     *                                                                                  mapper가 Object인 경우 사용
     * @since       1.2.1
    */
    pipe (target, events) {
        EventEmitter.pipe({
            source: this,
            target: target,
            events: events
        })

        return this
    }

    /**
     * @name        pipe
     * @memberof    EventEmitter
     * @function
     * @static
     * @public
     * @desc        event 발생 대상으로부터 target으로 이벤트 연결
     * @param       {Object}                    param                                   function parameter
     * @param       {Object}                    param.source                            이벤트 발생 대상
     * @param       {Object}                    param.target                            이벤트 연결 대상
     * @param       {Array<Object>}             param.events                            이벤트 연결 정보
     * @param       {String}                    param.events[].eventName                이벤트명
     * @param       {String}                    [param.events[].targetName]             target 이벤트명<br/>
     *                                                                                  값이 없으면 source 이벤트명 그대로 전달
     * @param       {Function}                  [param.events[].filter]                 filter 설정이 있는 경우, filter의 리턴값이 true인 경우에만 event 발생
     * @param       {Function}                  [param.events[].callback]               target event 호출 후 실행될 callback function
     * @param       {Array<Object>|Function}    [param.events[].mapper]                 target 으로 pipelining할 때, parameter를 remapping하거나 function으로 수정 및 전달 가능<br/>
     *                                                                                  <ul>
     *                                                                                      <li>Function : 함수를 실행시켜 source에서 전달된 parameter를 조작하여 target event로 전달 가능 (Array로 리턴하면 target event에 parameter로 전달)</li>
     *                                                                                      <li>Array<Object> : 세팅 값으로 parameter를 조작하여 target event로 전달 가능</li>
     *                                                                                  </ul>
     * @param       {Integer}                   [param.events[].mapper[].index]         source event에서 전달된 parameter index<br/>
     *                                                                                  index가 없는 경우는 target event로 전달되는 parameters에 추가되어 전달됨<br/>
     *                                                                                  mapper가 Object인 경우 사용
     * @param       {Integer}                   [param.events[].mapper[].targetIndex]   target event로 전달할 때의 parameter index<br/>
     *                                                                                  parameter 개수 부족시, index 가 변경될 수 있음<br/>
     *                                                                                  mapper가 Object인 경우 사용
     * @param       {Function|any}              [param.events[].mapper[].mapper]        source event에서 전달된 parameter를 전달받아 mapper를 실행하고 리턴값을 target event로 전달<br/>
     *                                                                                  mapper.index 값이 없고 mapper가 function 타입이 아니면 target event로 전달되는 paramter 끝에 추가<br/>
     *                                                                                  mapper가 Object인 경우 사용
     * @since       1.2.0
    */
    static pipe (param) {
        util.forEach(
            param.events,
            e => {
                if (param.source.listenerCount(e.eventName) >= param.source.getMaxListeners()) {
                    throw new Error(`source event listener count is more then max listener count (event name : ${e.eventName}, source listener count : ${param.source.listenerCount(e.eventName)}, max listener count : ${param.source.getMaxListeners()})`)
                } else {
                    param.source.on(
                        e.eventName,
                        (...args) => (!e.filter || (typeof e.filter === 'function' && e.filter())) && (param.target.emit(
                            e.targetName ? e.targetName : e.eventName,
                            ...(e.mapper ? (typeof e.mapper === 'function' ? e.mapper(...args) : getArgs(e, ...args)) : args)), typeof e.callback === 'function' && e.callback(...args)))
                }
            })

        function getArgs (e, ...args) {
            let value,
                mapInfo = util.map(args, (arg, index) => ({ sourceIndex: index, targetIndex: index }))

            return util.reduce(
                e.mapper,
                (_args, mapper) => {
                    if (validation.isPositiveInt(mapper.index)) {
                        if (args.length > mapper.index) {
                            value = typeof mapper.mapper === 'function' ? mapper.mapper(args[mapper.index]) : (mapper.mapper !== null && mapper.mapper !== undefined ? mapper.mapper : args[mapper.index])
                            validation.isPositiveInt(mapper.targetIndex) ? (
                                _args.splice(mapInfo[mapper.index].targetIndex, 1),
                                _args.splice(mapper.targetIndex, 0, value)
                            ) : (_args[mapInfo[mapper.index].targetIndex] = value)
                        }
                    } else {
                        // 추가
                        value = typeof mapper.mapper === 'function' ? mapper.mapper() : mapper.mapper
                        validation.isPositiveInt(mapper.targetIndex) ? (
                            _args.splice(mapper.targetIndex, 0, value),
                            _args.length > mapper.targetIndex && util.filter(mapInfo, info => info.targetIndex >= mapper.targetIndex, info => (info.targetIndex++, info))
                        ) : _args.push(value)
                    }

                    return _args
                },
                Array.from(args))
        }
    }
}

module.exports = exports = EventEmitter
