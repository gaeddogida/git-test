'use strict'

const util = require('../util')

Object.defineProperties(
    exports,
    {
        /**
         * @name        each
         * @memberof    module:async
         * @function
         * @static
         * @public
         * @desc        iterable 타입에 대해 순차적으로 순회하면서 전달된 콜백을 호출<br/>
         *              iterable 타입 :
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array Array},
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map Map},
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object Object},
         *               Array Like Object
         * @param       {any}                           obj         - 순회할 대상. 함수 타입이 전달되면 curried function 리턴
         * @param       {Function}                      callback    - 순회 중에 호출될 콜백 함수<br/>
         *                                                            콜백 함수 내에서 true를 리턴하면 순회 종료
         * @param       {Object=}                       thisArg     - callback이 호출될 때, this에 바인딩 되는 reference
         * @return      {Promise<any>|Function}         curried function 또는 Promise instance
         * @since       1.0.2
         * @date        2020-04-22
         * @see         {@link https://en.wikipedia.org/wiki/Currying Currying}
         * @todo        recursive 기능 추가
         * @example
         * const loop = require('../../async/loop'), 
         *     data = [
         *         {
         *             a: 10
         *         },
         *         {
         *             a: 20
         *         }
         *     ],
         *     map = new Map(),
         *     objData = {
         *         a: 10,
         *         b: 20
         *     }
         *
         * loop
         *     .each(data, (data, index) => new Promise((resolve) => setTimeout(() => {console.log('array data :', data), resolve()}, 1000)))
         *     .then(result => console.log('array result ', result))
         *     .catch(err => console.error(err))
         *
         * map.set('a', {a: 10})
         * 
         * loop
         *     .each(map, (data, index) => new Promise((resolve) => setTimeout(() => {console.log('map data :', data), resolve()}, 1000)))
         *     .then(result => console.log('map result ', result))
         *     .catch(err => console.error(err))
         *
         * loop
         *     .each(objData, (data, index) => new Promise((resolve) => setTimeout(() => {console.log('obj data :', data), resolve()}, 1000)))
         *     .then(result => console.log('obj result ', result))
         *     .catch(err => console.error(err))
         *
         * let curriedFn = loop
         *     .each((data, index) => new Promise((resolve) => setTimeout(() => {console.log('curried array data :', data), resolve()}, 1000))) 
         * 
         * curriedFn(data)
         *     .then(result => console.log('curried array result ', result))
         *     .catch(err => console.error(err))
        */
        each: {
            enumerable: true,
            value: function (obj, callback, thisArg) {
                let temp, result

                switch (true) {
                    case !obj || (typeof obj !== 'function' && typeof callback !== 'function'):
                        // 잘못된 전달인자의 경우 로직 수행 없이 obj 리턴
                        break
                    case obj.length >= 0 && typeof obj !== 'function':
                        // Array Live Object의 경우 for 문으로 처리
                        result = (async function _each (index) {
                            let result

                            if (obj[index]) {
                                result = await callback.call(thisArg, obj[index], index, obj)

                                if (!result) {
                                    return _each(index + 1)
                                }
                            }
                        })(0)
                            .then(() => obj)

                        break
                    case obj instanceof Map:
                        // Map
                        let entries = obj.entries()

                        result = (async function _each (entry) {
                            let result

                            if (!entry.done) {
                                result = await callback.call(thisArg, entry.value[1], entry.value[0], obj)

                                if (!result) {
                                    return _each(entries.next())
                                }
                            }
                        })(entries.next())
                            .then(() => obj)

                        break
                    case obj && typeof obj === 'object':
                        // 일반 Object 타입의 경우 attributes 리스트를 조회하여 순회
                        // 속성 descriptor.enumerable이 true인 것만 순회 가능

                        temp = util.keys(obj)

                        result = (async function _each (index) {
                            let attrName = temp[index], result

                            if (attrName) {
                                result = await callback.call(thisArg, obj[attrName], attrName, obj)

                                if (!result) {
                                    return _each(index + 1)
                                }
                            }
                        })(0)
                            .then(() => obj)

                        break
                    case typeof obj === 'function':
                        // Fuction 타입인 경우 curryR을 호출하여 curried function 리턴
                        thisArg = callback
                        callback = obj
                        result = util.curryR(exports.each, callback, thisArg)
                        break
                    default:
                        result = obj
                }

                return result
            }
        },
        /**
         * @name        forEach
         * @memberof    module:async
         * @function
         * @static
         * @public
         * @desc        iterable 타입에 대해 순차적으로 순회하면서 전달된 콜백을 호출<br/>
         *              function을 전달인자로 받으면 curried fucntion을 리턴<br/>
         *              iterable 타입 :
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array Array},
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map Map},
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object Object},
         *               Array Like Object
         * @param       {any}                           obj         - 순회할 대상. 함수 타입이 전달되면 curried function 리턴
         * @param       {Function}                      callback    - 순회 중에 호출될 콜백 함수<br/>
         *                                                            콜백 함수 내에서 true를 리턴하면 순회 종료
         * @param       {Object=}                       thisArg     - callback이 호출될 때, this에 바인딩 되는 reference
         * @return      {Promise<any>|Function}         curried function 또는 Promise instance
         * @since       1.0.2
         * @date        2020-04-22
         * @see         {@link https://en.wikipedia.org/wiki/Currying Currying}
         * @todo        recursive 기능 추가
        */
        forEach: {
            enumerable: true,
            value: function (obj, callback, thisArg) {
                let temp, result

                switch (true) {
                    case !obj || (typeof obj !== 'function' && typeof callback !== 'function'):
                        // 잘못된 전달인자의 경우 로직 수행 없이 obj 리턴
                        break
                    case obj.length >= 0 && typeof obj !== 'function':
                        // Array Live Object의 경우 for 문으로 처리
                        result = (async function _forEach (index) {
                            if (obj[index]) {
                                await callback.call(thisArg, obj[index], index, obj)
                                return _forEach(index + 1)
                            }
                        })(0)
                            .then(() => obj)

                        break
                    case obj instanceof Map:
                        // Map
                        let entries = obj.entries()

                        result = (async function _forEach (entry) {
                            if (!entry.done) {
                                await callback.call(thisArg, entry.value[1], entry.value[0], obj)
                                return _forEach(entries.next())
                            }
                        })(entries.next())
                            .then(() => obj)

                        break
                    case obj && typeof obj === 'object':
                        // 일반 Object 타입의 경우 attributes 리스트를 조회하여 순회
                        // 속성 descriptor.enumerable이 true인 것만 순회 가능

                        temp = util.keys(obj)

                        result = (async function _forEach (index) {
                            let attrName = temp[index]

                            if (attrName) {
                                await callback.call(thisArg, obj[attrName], attrName, obj)
                                return _forEach(index + 1)
                            }
                        })(0)
                            .then(() => obj)

                        break
                    case typeof obj === 'function':
                        // Fuction 타입인 경우 curryR을 호출하여 curried function 리턴
                        thisArg = callback
                        callback = obj
                        result = util.curryR(exports.forEach, callback, thisArg)
                        break
                    default:
                        result = obj
                }

                return result
            }
        },
        map: {
            enumerable: true,
            value: async (obj, mapper, thisArg) => {
                let isCallbackFn, arr

                return typeof obj === 'function' ? exports.curryR(exports.map, obj, mapper) : (
                    arr = [],
                    isCallbackFn = typeof mapper === 'function',
                    await exports.forEach(
                        obj,
                        async (v, k, obj) => arr.push(isCallbackFn ? await mapper.call(thisArg, v, k, obj) : v)),
                    arr)

            }
        }
    })
