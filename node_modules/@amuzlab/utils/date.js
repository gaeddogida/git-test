/**
 * http://usejsdoc.org/
 */
'use strict'

const string = require('./string'),
    validation = require('./validation'),

    MONTH_FULL_NAMES = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
    MONTH_SHORT_NAMES = ['Jan', 'Feb', 'March', 'April', 'May', 'June', 'July', 'August', 'Sep', 'Oct', 'Nov', 'Dec'],
    DATE_FULL_NAMES = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Thursday', 'Friday', 'Saturday'],
    DATE_SHORT_NAMES = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    MERIDIEM = {
        AM: 'AM',
        PM: 'PM'
    }

function _pad (target) {
    return /^[0-9]{1}$/.test(target) ? '0' + target : target;
}

function _toFormat (date, format) {
    return format
        .replace(/yyyy/ig, date.getFullYear())
        .replace(/yy/ig, String(date.getFullYear()).slice(2, 4))
        .replace(/MI/gi, _pad(date.getMinutes()))
        .replace(/MMMM/ig, MONTH_FULL_NAMES[date.getMonth()])
        .replace(/MMM/ig, MONTH_SHORT_NAMES[date.getMonth()])
        .replace(/MM/ig, _pad(date.getMonth() + 1))
        .replace(/M/ig, date.getMonth() + 1)
        .replace(/DDDD/ig, DATE_FULL_NAMES[date.getDay()])
        .replace(/DDD/ig, DATE_SHORT_NAMES[date.getDay()])
        .replace(/DD/ig, _pad(date.getDate()))
        .replace(/D/ig, date.getDate())
        .replace(/HH24/gi, _pad(date.getHours()))
        .replace(/HH/gi, _pad(date.getHours() %  12))
        .replace(/H/gi, date.getHours() %  12)
        .replace(/SSS/gi, string.padStart(date.getMilliseconds(), 3, '0'))
        .replace(/SS/gi, _pad(date.getSeconds()))
        .replace(/PP/gi, date.getHours() <= 12 ? MERIDIEM.AM : MERIDIEM.PM)
        .replace(/P/gi, (date.getHours() <= 12 ? MERIDIEM.AM : MERIDIEM.PM).toLowerCase());
}

Object.defineProperties(
    exports,
    {
        //{year, month, day, hour, minute, second, millisecond}
        // YYYY - Four digit year
        // YY   -
        // MMMM - Full month name. ie January
        // MMM  - Short month name. ie Jan
        // MM   - Zero padded month ie 01
        // M    - Month ie 1
        // DDDD - Full day or week name ie Tuesday
        // DDD  - Abbreviated day of the week ie Tue
        // DD   - Zero padded day ie 08
        // D    - Day ie 8
        // HH24 - Hours in 24 notation ie 18
        // HH   - Padded Hours ie 06
        // H    - Hours ie 6
        // MI   - Padded Minutes
        // SS   - Padded Seconds
        // SSS  - Padded Milliseconds
        // PP   - AM or PM
        // P    - am or pm
        /**
         * @name        toFormat
         * @function
         * @public
         * @static
         * @desc        날짜를 문자열 포맷으로 변경.
         * @param       {Date}    dateObject
        */
        toFormat: {
            enumerable: true,
            value: (dateObject, format) => {
                let temp, year, month, day, hours, minutes, seconds, milliseconds,
                    date = new Date()

                typeof dateObject === 'string' ? (temp = new Date(dateObject), isNaN(temp) ? format = dateObject : dateObject = temp) : null
                typeof format !== 'string' ? format = 'YYYY-MM-DD HH24:MI:SS' : null

                switch(true){
                    case dateObject instanceof Date:
                        date = dateObject
                        break
                    case dateObject && typeof dateObject === 'object':
                        year = date.getFullYear(),
                        month = date.getMonth(),
                        day = date.getDate(),
                        hours = date.getHours(),
                        minutes = date.getMinutes(),
                        seconds = date.getSeconds(),
                        milliseconds = date.getMilliseconds()

                        date = (
                            Number.isInteger(dateObject.year) ? year = dateObject.year : null,
                            Number.isInteger(dateObject.month) ? month = dateObject.month : null,
                            Number.isInteger(dateObject.day) ? day = dateObject.day : null,
                            Number.isInteger(dateObject.hours) ? hours = dateObject.hours : null,
                            Number.isInteger(dateObject.minutes) ? minutes = dateObject.minutes : null,
                            Number.isInteger(dateObject.seconds) ? seconds = dateObject.seconds : null,
                            Number.isInteger(dateObject.milliseconds) ? milliseconds = dateObject.milliseconds : null,
                            new Date(year, month, day, hours, minutes, seconds, milliseconds))
                        break
                    case validation.isPositiveInt(dateObject):
                        date = new Date(dateObject)
                        break
                }

                return _toFormat(date, format)
            }
        },
        parseUTC: {
            enumerable: true,
            value: date => {
                date = date instanceof Date ? date : new Date(date)

                return {
                    year: date.getUTCFullYear(),
                    month: date.getUTCMonth(),
                    day: date.getUTCDate(),
                    hour: date.getUTCHours(),
                    minute: date.getUTCMinutes(),
                    seconds: date.getUTCSeconds(),
                    milliseconds: date.getMilliseconds()
                }
            }
        },
        dateCompareTo: {
            enumerable: true,
            value: (date1, date2, criteria) => {
                typeof criteria === 'number' ? null : (criteria = exports.CRITERIA.MILLISECONDS)

                date1 = Date.UTC.apply(null, getArgs(exports.parseUTC(date1)))
                date2 = Date.UTC.apply(null, getArgs(exports.parseUTC(date2)))

                return (date1 - date2) / getMask(criteria)
            }
        },
        MASK: {
            enumerable: true,
            value: Object.create(null, {
                HOUR: {enumerable: true, value: 24},
                MINUTE: {enumerable: true, value: 60},
                SECONDS: {enumerable: true, value: 60},
                MILLISECONDS: {enumerable: true, value: 1000}
            })
        },
        CRITERIA: {
            enumerable: true,
            value: Object.create(null, {
                YEAR: {enumerable: true, value: 0},
                MONTH: {enumerable: true, value: 1},
                DAY: {enumerable: true, value: 2},
                HOUR: {enumerable: true, value: 3},
                MINUTE: {enumerable: true, value: 4},
                SECONDS: {enumerable: true, value: 5},
                MILLISECONDS: {enumerable: true, value: 6}
            })
        },
        toDate: {
            enumerable: true,
            value: (strDate, format) => {
                let regExps = {
                    years: {
                        regExps: [
                            /YYYY/ig,
                            /YYY/ig,
                            /YY/ig,
                            /Y/ig
                        ],
                        type: 'integer'
                    },
                    minutes: {
                        regExps: [
                            /MM/g,
                            /M/g
                        ],
                        type: 'integer'
                    },
                    date: {
                        regExps: [
                            /DD/g,
                            /D/g
                        ],
                        type: 'integer'
                    },
                    hours: {
                        regExps: [
                            /HH24/ig,
                            /HH/ig,
                            /H/ig,
                        ],
                        type: 'integer',
                    }
                }
                [
                    /HH24/ig,
                    /HH/ig,
                    /H/ig,
                    /mm/g,
                    /MI/ig,
                    /m/g,
                    /ss/ig,
                    /s/ig
                ],
                    maskBuffer = Buffer.alloc(strDate.length)

                getDateTime(strDate, format, regExp, maskBuffer)
            }
        },
        /**
         * @name        toTimeFormat
         * @desc        전달된 시간값을 형식에 맞게 변환해서 리턴
         * @function
         * @static
         * @public
         * @param       {Number}    time                        time value (sec)
         * @param       {String=}   [timeFormat='HH:mm:ss.ms']  time format
         * @returns     {String}    time format
         * @since       1.1.1
        */
        toTimeFormat: {
            enumerable: true,
            value: (time, timeFormat) => {
                let temp = Math.floor(time),
                    ms = Math.floor((time - temp) * 1000),
                    sec = temp % 60,
                    min = Math.floor(temp / 60) % 60,
                    hours = Math.floor(temp / 3600)

                return `${hours.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`
            }
        }
    })

function getMask (criteria) {
    return Object.keys(exports.CRITERIA)
        .filter(_key => criteria < exports.CRITERIA[_key.toUpperCase()])
        .reduce((_mask, _key) => _mask * exports.MASK[_key], 1);
}

function getArgs (date) {
    return Object.keys(date).map(key => date[key]);
}

/**
 * @name        getDateTime
 * @function
 * @private
 * @static
*/
function getDateTime (strDate, format, regExp, maskBuffer) {
    let match, data = null, mask = 0b11111111

    while ((match = regExp.exec(format)) !== null) {
        if (maskBuffer.readInt8(match.index) !== mask && maskBuffer.readInt8(regExp.lastIndex - 1) !== mask) {
            data = strDate.substring(match.index, regExp.lastIndex)
            maskBuffer.fill(mask, match.index, regExp.lastIndex)
        }
    }

    return data
}
