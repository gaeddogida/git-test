'use strict'

/**
 * @module      util
 * @desc        util 모듈의 기본 모듈
 * @since       0.0.1
 * @date        2019-02-25
 * @requires    {@link https://nodejs.org/en/docs/ Node.js 0.10.x 이상 버전}
*/

Object.defineProperties(
    exports,
    {
        /**
         * @name $_MARKER
         * @static
         * @public
         * 
         * @type        {Object}
         * @desc        curry 함수 전달인자에 late parameter 마킹
         * @author      예장해
         * @date        2019-02-25
        */
        $_MARKER: {
            enumerable: true,
            value: {}
        },
        /**
         * @name        each
         * @function
         * @static
         * @public
         * @desc        iterable 타입에 대해 순차적으로 순회하면서 전달된 콜백을 호출<br/>
         *              iterable 타입 :
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array Array},
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map Map},
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object Object},
         *               Array Like Object
         * @param       {any}                           obj         - 순회할 대상. 함수 타입이 전달되면 curried function 리턴
         * @param       {Function}                      callback    - 순회 중에 호출될 콜백 함수<br/>
         *                                                            콜백 함수 내에서 true를 리턴하면 순회 종료
         * @param       {Object=}                       thisArg     - callback이 호출될 때, this에 바인딩 되는 reference
         * @return      {any}                           전달된 obj 또는 curried function을 리턴
         * @since       0.0.1
         * @date        2019-02-25
         * @see         {@link https://en.wikipedia.org/wiki/Currying Currying}
         * @todo        recursive 기능 추가
         * @example
         * const util = require('util'),
         *     arr = [1, 2],
         *     arrayLikeObj = {'0': 1, '1', 2, length: 2},
         *     callback = (element, index, arr) => {
         *         console.log(`element : ${element}, index : ${index}, arr : ${JSON.stringify(arr)}`)
         *     },
         *     thisArg = {name: 'thisArg'},
         *     obj = {a: '10', b: {c: 1}},
         *     map = new Map()
         *
         * map.set('a', 10)
         * map.set('b', 20)
         *
         * let curriedFn
         *
         * util.each(
         *     arr,
         *     (element, index, arr) => console.log(`element : ${element}, index : ${index}, arr : ${JSON.stringify(arr)}`))
         * // element : 1, index : 0, arr : [1,2]
         * // element : 2, index : 1, arr : [1,2]
         *
         * util.each(
         *     arrayLikeObj,
         *     (element, index, arr) => console.log(`element : ${element}, index : ${index}, arr : ${JSON.stringify(arr)}`))
         * // element : 1, index : 0, arr : [1,2]
         * // element : 2, index : 1, arr : [1,2]
         *
         * util.each(
         *     obj,
         *     (value, key, obj) => console.log('value :', value, ', key :', key, ', obj :', JSON.stringify(obj)))
         * // value : 10, key : a, obj : {"a":"10","b":{"c":1}}
         * // value : { c: 1 }, key : b, obj : {"a":"10","b":{"c":1}}
         *
         * util.each(
         *     map,
         *     (value, key, map) => console.log('value :', value, ', key :', key, ', map :', map))
         * // value : 10, key : a, map : Map { 'a' => 10, 'b' => 20 }
         * // value : 20, key : a, map : Map { 'a' => 10, 'b' => 20 }
         *
         * curriedFn = util.each(
         *     callback)
         * curriedFn(arr)
         * // element : 1, index : 0, arr : [1,2]
         * // element : 2, index : 1, arr : [1,2]
         *
         * util.each(
         *     arr,
         *     function (element, index, arr) {
         *         console.log(`element : ${element}, index : ${index}, arr : ${JSON.stringify(arr)}, thisArg : ${JSON.stringify(this)}`)
         *     },
         *     thisArg)
         * // element : 1, index : 0, arr : [1,2], thisArg : {name:"thisArg"}
         * // element : 2, index : 1, arr : [1,2], thisArg : {name:"thisArg"}
        */
        each: {
            enumerable: true,
            value: function (obj, callback, thisArg) {
                switch (true) {
                    case !obj || (typeof obj !== 'function' && typeof callback !== 'function'):
                        // 잘못된 전달인자의 경우 로직 수행 없이 obj 리턴
                        break
                    case obj.length >= 0 && typeof obj !== 'function':
                        // Array Live Object의 경우 for 문으로 처리
                        for (let i = 0; i < obj.length; i++) {
                            if(callback.call(thisArg, obj[i], i, obj))
                                break
                        }
                        break;
                    case obj instanceof Map:
                        // Map
                        let entries = obj.entries(),
                            entry

                        while (entry = entries.next(), !entry.done) {
                            if(callback.call(thisArg, entry.value[1], entry.value[0], obj))
                                break
                        }

                        break
                    case obj && typeof obj === 'object':
                        // 일반 Object 타입의 경우 attributes 리스트를 조회하여 순회
                        // 속성 descriptor.enumerable이 true인 것만 순회 가능

                        for (let attrName in obj) {
                            if(callback.call(thisArg, obj[attrName], attrName, obj))
                                break
                        }
                        break
                    case typeof obj === 'function':
                        // Fuction 타입인 경우 curryR을 호출하여 curried function 리턴
                        thisArg = callback
                        callback = obj
                        obj = exports.curryR(exports.each, callback, thisArg)
                        break
                }

                return obj
            }
        },
        /**
         * @name        forEach
         * @function
         * @static
         * @public
         * @desc        iterable 타입에 대해 순차적으로 순회하면서 전달된 콜백을 호출<br/>
         *              function을 전달인자로 받으면 curried fucntion을 리턴<br/>
         *              iterable 타입 :
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array Array},
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map Map},
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object Object},
         *               Array Like Object
         * @param       {any}                           obj         - 순회할 대상. 함수 타입이 전달되면 curried function 리턴
         * @param       {Function}                      callback    - 순회 중에 호출될 콜백 함수<br/>
         *                                                            each와 달리, 콜백 함수 내에서 true를 리턴해도 순회 종료는 되지 않음
         * @param       {Object=}                       thisArg     - callback이 호출될 때, this에 바인딩 되는 reference
         * @return      {any}                           전달된 obj 또는 curried function 리턴
         * @since       0.0.1
         * @date        2019-02-25
         * @see         {@link https://en.wikipedia.org/wiki/Currying Currying}
         * @todo        recursive 기능 추가
         * @example
         * const util = require('util'),
         *     arr = [1, 2],
         *     arrayLikeObj = {'0': 1, '1', 2, length: 2},
         *     callback = (element, index, arr) => {
         *         console.log(`element : ${element}, index : ${index}, arr : ${JSON.stringify(arr)}`)
         *     },
         *     thisArg = {name: 'thisArg'},
         *     obj = {a: '10', b: {c: 1}},
         *     map = new Map()
         *
         * map.set('a', 10)
         * map.set('b', 20)
         *
         * let curriedFn
         *
         * util.forEach(
         *     arr,
         *     (element, index, arr) => console.log(`element : ${element}, index : ${index}, arr : ${JSON.stringify(arr)}`))
         * // element : 1, index : 0, arr : [1,2]
         * // element : 2, index : 1, arr : [1,2]
         *
         * util.forEach(
         *     arrayLikeObj,
         *     (element, index, arr) => console.log(`element : ${element}, index : ${index}, arr : ${JSON.stringify(arr)}`))
         * // element : 1, index : 0, arr : [1,2]
         * // element : 2, index : 1, arr : [1,2]
         *
         * util.forEach(
         *     obj,
         *     (value, key, obj) => console.log('value :', value, ', key :', key, ', obj :', JSON.stringify(obj)))
         * // value : 10, key : a, obj : {"a":"10","b":{"c":1}}
         * // value : { c: 1 }, key : b, obj : {"a":"10","b":{"c":1}}
         *
         * util.forEach(
         *     map,
         *     (value, key, map) => console.log('value :', value, ', key :', key, ', map :', map))
         * // value : 10, key : a, map : Map { 'a' => 10, 'b' => 20 }
         * // value : 20, key : a, map : Map { 'a' => 10, 'b' => 20 }
         *
         * curriedFn = util.forEach(
         *     callback)
         * curriedFn(arr)
         * // element : 1, index : 0, arr : [1,2]
         * // element : 2, index : 1, arr : [1,2]
         *
         * util.forEach(
         *     arr,
         *     function (element, index, arr) {
         *         console.log(`element : ${element}, index : ${index}, arr : ${JSON.stringify(arr)}, thisArg : ${JSON.stringify(this)}`)
         *     },
         *     thisArg)
         * // element : 1, index : 0, arr : [1,2], thisArg : {name:"thisArg"}
         * // element : 2, index : 1, arr : [1,2], thisArg : {name:"thisArg"}
        */
        forEach: {
            enumerable: true,
            value: function (obj, callback, thisArg) {
                switch (true) {
                    case !obj || (typeof obj !== 'function' && typeof callback !== 'function'):
                        // 잘못된 전달인자의 경우 로직 수행 없이 obj 리턴
                        break
                    case obj.length >= 0 && typeof obj !== 'function':
                        // Array Live Object의 경우 for 문으로 처리
                        for (let i = 0; i < obj.length; i++)
                            callback.call(thisArg, obj[i], i, obj)
                        break
                    case obj instanceof Map:
                        // Map
                        let entries = obj.entries(),
                            entry

                        while (entry = entries.next(), !entry.done)
                            callback.call(thisArg, entry.value[1], entry.value[0], obj)

                        break
                    case obj && typeof obj === 'object':
                        // 일반 Object 타입의 경우 attributes 리스트를 조회하여 순회
                        // 속성 descriptor.enumerable이 true인 것만 순회 가능
                        for (let attrName in obj)
                            callback.call(thisArg, obj[attrName], attrName, obj)
                        break
                    case typeof obj === 'function':
                        // Fuction 타입인 경우 curryR을 호출하여 curried function 리턴
                        thisArg = callback
                        callback = obj
                        obj = exports.curryR(exports.forEach, obj, callback)
                        break
                }

                return obj
            }
        },
        /**
         * @name        some
         * @function
         * @static
         * @public
         * @desc        iterable 타입에 대해 순차적으로 순회하면서 전달된 콜백을 호출<br/>
         *              function을 전달인자로 받으면 curried fucntion을 리턴<br/>
         *              iterable 타입 :
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array Array},
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map Map},
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object Object},
         *               Array Like Object
         * @param       {any}                           obj         - 순회할 대상. 함수 타입이 전달되면 curried function 리턴
         * @param       {Function}                      callback    - 순회 중에 호출될 콜백 함수<br/>
         *                                                            콜백 함수가 true를 리턴하면 순회 종료 및 some 결과를 true로 리턴
         * @param       {Object=}                       thisArg     - callback이 호출될 때, this에 바인딩 되는 reference
         * @return      {Boolean|Function}              callback의 호출 결과가 참(truthy)인 경우, true, 그 외의 경우 false<br/>
         *                                              obj가 Function 인 경우 curried function 리턴
         * @since       0.0.1
         * @date        2019-02-25
         * @see         {@link https://en.wikipedia.org/wiki/Currying Currying}
         * @see         {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/some Array.prototype.some}
         * @todo        recursive 기능 추가
         * @example
         * const util = require('util'),
         *     arr = [1, 2],
         *     arrayLikeObj = {'0': 1, '1', 2, length: 2},
         *     callback = (element, index, arr) => {
         *         console.log(`element : ${element}, index : ${index}, arr : ${JSON.stringify(arr)}`)
         *     },
         *     thisArg = {name: 'thisArg'},
         *     obj = {a: '10', b: {c: 1}},
         *     map = new Map()
         *
         * map.set('a', 10)
         * map.set('b', 20)
         *
         * let curriedFn
         *
         * util.forEach(
         *     arr,
         *     (element, index, arr) => console.log(`element : ${element}, index : ${index}, arr : ${JSON.stringify(arr)}`))
         * // element : 1, index : 0, arr : [1,2]
         * // element : 2, index : 1, arr : [1,2]
         *
         * util.forEach(
         *     arrayLikeObj,
         *     (element, index, arr) => console.log(`element : ${element}, index : ${index}, arr : ${JSON.stringify(arr)}`))
         * // element : 1, index : 0, arr : [1,2]
         * // element : 2, index : 1, arr : [1,2]
         *
         * util.forEach(
         *     obj,
         *     (value, key, obj) => console.log('value :', value, ', key :', key, ', obj :', JSON.stringify(obj)))
         * // value : 10, key : a, obj : {"a":"10","b":{"c":1}}
         * // value : { c: 1 }, key : b, obj : {"a":"10","b":{"c":1}}
         *
         * util.forEach(
         *     map,
         *     (value, key, map) => console.log('value :', value, ', key :', key, ', map :', map))
         * // value : 10, key : a, map : Map { 'a' => 10, 'b' => 20 }
         * // value : 20, key : a, map : Map { 'a' => 10, 'b' => 20 }
         *
         * curriedFn = util.forEach(
         *     callback)
         * curriedFn(arr)
         * // element : 1, index : 0, arr : [1,2]
         * // element : 2, index : 1, arr : [1,2]
         *
         * util.forEach(
         *     arr,
         *     function (element, index, arr) {
         *         console.log(`element : ${element}, index : ${index}, arr : ${JSON.stringify(arr)}, thisArg : ${JSON.stringify(this)}`)
         *     },
         *     thisArg)
         * // element : 1, index : 0, arr : [1,2], thisArg : {name:"thisArg"}
         * // element : 2, index : 1, arr : [1,2], thisArg : {name:"thisArg"}
        */
        some: {
            enumerable: true,
            value: function (obj, callback, thisArg) {
                let result = false

                return typeof obj === 'function' ? (result = exports.curryR(exports.some, obj, callback)) : (typeof callback === 'function' ? exports.each(
                    obj,
                    (v, k, obj) =>
                    (result = (callback.call(thisArg, v, k, obj) ? true : false))) : null), result
            }
        },
        /**
         * @name        toArray
         * @function
         * @static
         * @public
         * @desc        obj parameter로 전달된 데이터에 대해 Array로 만들어서 리턴<br/>
         *              key / value 구조의 객체는 Array<{key, value}> 타입으로 생성되어 리턴<br/>
         *              Array Like Object의 경우 Array<> 로 생성되어 리턴
         *              iterable 타입 :
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array Array},
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map Map},
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object Object},
         *               Array Like Object
         * @param       {any}                           obj         - Array로 만들 대상. 함수 타입이 전달되면 curried function 리턴
         * @param       {Function}                      mapper      - Array 생성 중 element당 호출되는 콜백함수<br/>
         *                                                            mapper에서 리턴된 값이 생성된 Array의 element가 된다
         * @param       {Object=}                       thisArg     - mapper가 호출될 때, this에 바인딩 되는 reference
         * @return      {Array|Function}                생성된 Array<br/>
         *                                              obj가 Function 인 경우 curried function 리턴
         * @since       0.0.1
         * @date        2019-02-25
         * @see         {@link https://en.wikipedia.org/wiki/Currying Currying}
         * @example
         * const utils = require('util')
         * 
         * console.log(utils.toArray(1))
         * // [ 1 ]
         *
         * console.log(utils.toArray({a: 1, b: 2}))
         * // [ { key: 'a', value: 1 }, { key: 'b', value: 2 } ]
         *
         * console.log(utils.toArray([1, 2]))
         * // [ 1, 2 ]
         *
         * console.log(utils.toArray({'0': 1, '1': 2, length: 2}))
         * // [ 1, 2 ]
         *
         * let curriedFn = utils.toArray((value, key) => {
         *     return value
         * })
         * console.log(curriedFn)
         * // [Function]
         * console.log(curriedFn({a: 1, b: 2}))
         * // [ 1, 2 ]
         *
         * let map = new Map()
         * map.set('a', 1)
         * map.set('b', {c: 2})
         * console.log(utils.toArray(map))
         * // [ { key: 'a', value: 1 }, { key: 'b', value: { c: 2 } } ]
        */
        toArray: {
            enumerable: true,
            value: function (obj, mapper, thisArg) {
                const isMapperFn = typeof mapper === 'function'
                let hasLength, arr = []

                return typeof obj === 'function' ? exports.curryR(exports.toArray, obj, mapper) : (obj !== undefined && typeof obj !== 'object' ? arr.push(obj) : exports.forEach(
                    obj,
                    (v, k, obj) =>
                    arr.push(isMapperFn ? mapper.call(thisArg, v, k, obj) : (hasLength || (hasLength = obj.hasOwnProperty('length')) ? v : {
                        key: k,
                        value: v
                    }))), arr)
            }
        },
        /**
         * @name        reduce
         * @function
         * @static
         * @public
         * @desc        obj parameter로 전달된 데이터에 대해 reducer 함수를 실행<br/>
         *              function을 전달인자로 받으면 curried fucntion을 리턴<br/>
         *              iterable 타입 :
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array Array},
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map Map},
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object Object},
         *               Array Like Object
         * @param       {any}                           obj         - 순회할 대상. 함수 타입이 전달되면 curried function 리턴
         * @param       {Function}                      reducer     - 순회 중에 호출될 콜백 함수<br/>
         *                                                            reducer에서 리턴한 값이 다음 reducer가 호출될 때 전달되는 방식으로 누적된다
         * @param       {Object=}                       thisArg     - reducer가 호출될 때, this에 바인딩 되는 reference
         * @return      {any}                           마지막 reducer가 호출될 때 리턴된 값<br/>
         *                                              obj가 Function 인 경우 curried function 리턴
         * @since       0.0.1
         * @date        2019-02-25
         * @see         {@link https://en.wikipedia.org/wiki/Currying Currying}
         * @see         {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce Array.prototype.reduce}
        */
        reduce: {
            enumerable: true,
            value: function (obj, reducer, initData, thisArg) {
                let isFirst = true,
                    isInitData = arguments.length >= 3

                return typeof obj === 'function' ? (initData = exports.curryR(exports.reduce, obj, reducer, initData)) : (typeof reducer === 'function' ? exports.forEach(obj, (v, k, obj) => (
                    initData = reducer.call(thisArg, !isInitData && isFirst ? (isFirst = false, v) : initData, v, k ,obj))) : null), initData
            }
        },
        /**
         * @name        filter
         * @function
         * @static
         * @public
         * @desc        obj parameter로 전달된 데이터에 대해 callback 함수를 실행하여 새로운 Array 리턴<br/>
         *              callback 함수의 리턴값이 true인 element만 리턴되는 Array에 추가<br/>
         *              function을 전달인자로 받으면 curried fucntion을 리턴<br/>
         *              iterable 타입 :
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array Array},
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map Map},
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object Object},
         *               Array Like Object
         * @param       {any}                           obj         - 순회할 대상. 함수 타입이 전달되면 curried function 리턴
         * @param       {Function}                      callback    - 순회 중에 호출될 콜백 함수<br/>
         *                                                            callback 함수의 리턴값이 true인 element만 리턴되는 Array에 추가
         * @param       {Function}                      mapper      - Array 생성 중 callback 함수의 리턴값이 true인 element 마다 호출되는 콜백함수<br/>
         *                                                            mapper에서 리턴된 값이 생성된 Array의 element가 된다
         * @param       {Object=}                       thisArg     - callback 및 mapper 함수가 호출될 때, this에 바인딩 되는 reference
         * @return      {Array|Function}                filtering된 결과<br/>
         *                                              obj가 function인 경우 carried function 리턴
         * @since       0.0.1
         * @date        2019-02-25
         * @see         {@link https://en.wikipedia.org/wiki/Currying Currying}
         * @see         {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/filter Array.prototype.filter}
        */
        filter: {
            enumerable: true,
            value: function (obj, callback, mapper, thisArg) {
                let isMapperFn

                return typeof obj === 'function' ? exports.curryR(exports.filter, obj, callback, mapper) : (typeof callback === 'function' ? (
                    isMapperFn = typeof mapper === 'function',
                    arguments.length === 3 ? (!isMapperFn && typeof mapper === 'object' ? (thisArg = mapper) : null) : null,
                    exports.reduce(
                        obj,
                        (arr, v, k, obj) => (callback.call(thisArg, v, k, obj) ? arr.push(isMapperFn ? mapper.call(thisArg, v, k, obj) : v) : null, arr),
                        [])) : [])
            }
        },
        /**
         * @name        find
         * @function
         * @static
         * @public
         * @desc        obj parameter로 전달된 데이터에 대해 callback 함수를 실행하여 첫번째로 true를 리턴한 element를 리턴<br/>
         *              function을 전달인자로 받으면 curried fucntion을 리턴<br/>
         *              iterable 타입 :
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array Array},
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map Map},
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object Object},
         *               Array Like Object
         * @param       {any}                           obj         - 순회할 대상. 함수 타입이 전달되면 curried function 리턴
         * @param       {Function}                      callback    - 순회 중에 호출될 콜백 함수<br/>
         *                                                            callback 함수의 리턴값이 true인 element를 리턴
         * @param       {Function}                      mapper      - callback 함수의 결과가 true인 element 를 전달하여 mapper를 실행 후 mapper에서 리턴하는 값을 최종 리턴<br/>
         * @param       {Object=}                       thisArg     - callback 및 mapper 함수가 호출될 때, this에 바인딩 되는 reference
         * @return      {any}                           callback 함수의 리턴값이 true인 element
         *                                              obj가 function인 경우 carried function 리턴
         * @since       0.0.1
         * @date        2019-02-25
         * @see         {@link https://en.wikipedia.org/wiki/Currying Currying}
         * @see         {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/find Array.prototype.find}
        */
        find: {
            enumerable: true,
            value: function (obj, callback, mapper, thisArg) {
                let result, isMapperFn

                return typeof obj === 'function' ? exports.curryR(exports.find, obj, callback, mapper) : (typeof callback === 'function' ? (
                    isMapperFn = typeof mapper === 'function',
                    arguments.length === 3 ? (!isMapperFn && typeof mapper === 'object' ? (thisArg = mapper) : null) : null,
                    exports.each(
                        obj,
                        (v, k, obj) =>
                        callback.call(thisArg, v, k, obj) ? (result = isMapperFn ? mapper.call(thisArg, v, k, obj) : v, true) : false)) : null, result)
            }
        },
        /**
         * @name        findIndex
         * @function
         * @static
         * @public
         * @desc        obj parameter로 전달된 데이터에 대해 callback 함수를 실행하여 첫번째로 true를 리턴한 element의 index를 리턴<br/>
         *              function을 전달인자로 받으면 curried fucntion을 리턴<br/>
         * @param       {Array|ArrayLikeObject|Function}        obj         - 순회할 대상. 함수 타입이 전달되면 curried function 리턴
         * @param       {Function}                              callback    - 순회 중에 호출될 콜백 함수<br/>
         *                                                                    callback 함수의 리턴값이 true인 element의 index를 리턴
         * @param       {Object=}                               thisArg     - callback 함수가 호출될 때, this에 바인딩 되는 reference
         * @return      {Number|Function}                       callback 함수의 리턴값이 true인 element의 index<br/>
         *                                                      obj가 function인 경우 carried function 리턴
         * @since       0.0.1
         * @date        2019-02-25
         * @see         {@link https://en.wikipedia.org/wiki/Currying Currying}
         * @see         {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex Array.prototype.findIndex}
        */
        findIndex: {
            enumerable: true,
            value: (obj, callback, thisArg) => {
                let index

                switch (true) {
                    case obj && typeof obj === 'object' && obj.length >= 0 && typeof callback === 'function':
                        for (let i = 0; i < obj.length; i++) {
                            if (callback.call(thisArg, obj[i], i, obj)) {
                                index = i
                                break
                            }
                        }
                        break
                    case typeof obj === 'function':
                        index = exports.curryR(exports.findIndex, obj, callback)
                        break
                }

                return index
            }
        },
        /**
         * @name        findKey
         * @function
         * @static
         * @public
         * @desc        obj parameter로 전달된 데이터에 대해 callback 함수를 실행하여 첫번째로 true를 리턴한 element의 key를 리턴<br/>
         *              function을 전달인자로 받으면 curried fucntion을 리턴<br/>
         *              iterable 타입 :
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array Array},
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map Map},
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object Object},
         *               Array Like Object
         * @param       {any}               obj         - 순회할 대상. 함수 타입이 전달되면 curried function 리턴
         * @param       {Function}          callback    - 순회 중에 호출될 콜백 함수<br/>
         *                                                callback 함수의 리턴값이 true인 element의 key를 리턴
         * @param       {Object=}           thisArg     - callback 함수가 호출될 때, this에 바인딩 되는 reference
         * @return      {any}               callback 함수의 리턴값이 true인 element의 key<br/>
         *                                  obj가 function인 경우 carried function 리턴
         * @since       0.0.1
         * @date        2019-02-25
         * @see         {@link https://en.wikipedia.org/wiki/Currying Currying}
        */
        findKey: {
            enumerable: true,
            value: (obj, callback, thisArg) => {
                let index

                switch (true) {
                    case typeof obj === 'function':
                        index = exports.curryR(exports.findKey, obj, callback)
                        break
                    case obj && typeof obj === 'object' && typeof callback === 'function':
                        exports.some(obj, (v, k, obj) => callback.call(thisArg, v, k, obj) ? (index = k, true) : false)
                        break
                }

                return index
            }
        },
        /**
         * @name        map
         * @function
         * @static
         * @public
         * @desc        obj parameter로 전달된 데이터에 대해 mapper 함수를 실행하여 리턴된 값을 새로운 Array에 담아 리턴<br/>
         *              function을 전달인자로 받으면 curried fucntion을 리턴<br/>
         *              iterable 타입 :
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array Array},
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map Map},
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object Object},
         *               Array Like Object
         * @param       {any}               obj         - 순회할 대상. 함수 타입이 전달되면 curried function 리턴
         * @param       {Function}          mapper      - 순회 중에 호출될 콜백 함수<br/>
         *                                                mapper 함수의 리턴값을 새로운 Array에 담아 리턴
         * @param       {Object=}           thisArg     - mapper 함수가 호출될 때, this에 바인딩 되는 reference
         * @return      {Array|Function}    callback 함수의 리턴값이 true인 element의 key<br/>
         *                                  obj가 function인 경우 carried function 리턴
         * @since       0.0.1
         * @date        2019-02-25
         * @see         {@link https://en.wikipedia.org/wiki/Currying Currying}
         * @see         {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/map Array.prototype.map}
        */
        map: {
            enumerable: true,
            value: (obj, mapper, thisArg) => {
                let isCallbackFn, arr

                return typeof obj === 'function' ? exports.curryR(exports.map, obj, mapper) : (
                    arr = [],
                    isCallbackFn = typeof mapper === 'function',
                    exports.forEach(obj, (v, k, obj) => arr.push(isCallbackFn ? mapper.call(thisArg, v, k, obj) : v)),
                    arr)

            }
        },
        /**
         * @name        keys
         * @function
         * @static
         * @public
         * @desc        obj parameter로 전달된 데이터 내의 attribute 들을 Array에 담아 리턴<br/>
         *              function을 전달인자로 받으면 curried fucntion을 리턴<br/>
         *              iterable 타입 :
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array Array},
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map Map},
         *               {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object Object},
         *               Array Like Object
         * @param       {any}               obj         - 순회할 대상. 함수 타입이 전달되면 curried function 리턴
         * @return      {Array|Function}    obj 데이터 내의 attribute 들을 element로 하는 Array<br/>
         *                                  obj가 function인 경우 carried function 리턴
         * @since       0.0.1
         * @date        2019-02-25
         * @see         {@link https://en.wikipedia.org/wiki/Currying Currying}
         * @see         {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/keys Object.keys}
        */
        keys: {
            enumerable: true,
            value: obj => exports.map(obj, (v, k) => k)
        },
        /**
         * @name        slice
         * @function
         * @static
         * @public
         * @desc        obj parameter로 전달된 배열 또는 Array Like Object의 start부터 end까지의 element들을새로운 Array에 담아 리턴. end에 해당하는 element는 포함되지 않음<br/>
         *              function을 전달인자로 받으면 curried fucntion을 리턴<br/>
         * @param       {Array|ArrayLikeObject}     obj         - 순회할 대상. 함수 타입이 전달되면 curried function 리턴
         * @param       {(Number|String|Array)=}    start       - slice할 시작 index
         * @param       {(Number|String)=}          end         - slice를 종료할 index
         * @param       {Function=}                 mapper      - slice되는 element를 전달하여 실행되는 함수. mapper에서 리턴되는 값을 slice 결과에 포함
         * @param       {Object=}                   thisArg     - mapper 함수가 호출될 때, this에 바인딩 되는 reference
         * @return      {Array|Function}            obj 데이터 내의 attribute 들을 element로 하는 Array<br/>
         *                                          obj가 function인 경우 carried function 리턴
         * @since       0.0.1
         * @date        2019-02-25
         * @see         {@link https://en.wikipedia.org/wiki/Currying Currying}
         * @see         {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/slice Array.prototype.slice}
         * @todo        deep copy로 리턴하는 기능 구현
        */
        slice: {
            enumerable: true,
            value: function (obj, start, end, mapper, thisArg) {
                if (typeof obj === 'number' || typeof obj === 'string') {
                    return exports.curryR(exports.slice, obj, start, end, mapper)
                }

                let objIsLikeArr,
                    isMapperFn = typeof mapper === 'function',
                    result = []
                const startIsArr = Array.isArray(start)

                if (arguments.length < 2 || (!startIsArr && !/^[+]?[0-9]+$/.test(start)) || !obj) {
                    return result
                }

                objIsLikeArr = obj && obj.length >= 0

                if (typeof end === 'function') {
                    if (mapper && typeof mapper === 'object') {
                        thisArg = mapper
                    }

                    mapper = end
                    isMapperFn = true
                }

                objIsLikeArr && !startIsArr && (/^[+]?[0-9]+$/.test(end) ? (obj.length > end ? null : (end = obj.length - 1)) : (end = obj.length - 1))

                typeof start === 'string' && (start = parseInt(start))
                typeof end === 'string' && (end = parseInt(end))

                switch (true) {
                    case objIsLikeArr === true && !startIsArr:
                        for (let i = start; i <= end; i++) {
                            result.push(isMapperFn ? mapper.call(thisArg, obj[i], i, obj) : obj[i])
                        }
                        break
                    default:
                        result = exports.filter(
                            obj,
                            (v, k) => startIsArr ? exports.some(start, v => v === k) : start <= k && k <= end,
                            isMapperFn ? mapper : (v, k) => objIsLikeArr ? v : {
                                key: k,
                                value: v
                            },
                            thisArg)
                }

                return result
            }
        },
        /**
         * @name        splice
         * @function
         * @static
         * @public
         * @desc        obj parameter로 전달된 배열 또는 Array Like Object의 element를 삭제 또는 추가<br/>
         *              function을 전달인자로 받으면 curried fucntion을 리턴<br/>
         * @param       {Array|ArrayLikeObject}     obj             - 변경할 대상. 함수 타입이 전달되면 curried function 리턴
         * @param       {Array|ArrayLikeObject}     start           - 변경을 시작할 index<br/>
         *                                                            obj의 길이보다 큰 값이라면 실제 시작 인덱스는 배열의 길이로 설정<br/>
         *                                                            음수인 경우 obj의 끝에서부터 index 계산
         * @param       {(Array|ArrayLikeObject)=}  deleteCount     - 제거할 element의 수<br/>
         *                                                            deleteCount를 생략하거나 값이 array.length - start보다 크면 start부터의 모든 요소를 제거<br/>
         *                                                            deleteCount가 0 이하라면 items로 전달된 데이터들을 obj에 추가
         * @param       {...Object=}                ...items
         * @return      {Array|Function}            obj<br/>
         *                                          obj가 function인 경우 carried function 리턴
         * @since       0.0.1
         * @date        2019-02-25
         * @see         {@link https://en.wikipedia.org/wiki/Currying Currying}
         * @see         {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/splice Array.prototype.splice}
        */
        splice: {
            enumerable: true,
            value: function (obj, start, deleteCount) {
                if (typeof obj === 'number') {
                    let _args = exports.toArray(arguments)
                    return exports.curryR.apply(null, (_args.unshift(exports.splice), _args))
                }

                let result = [], end, args

                switch (true) {
                    case !obj || !/^[-+]?[0-9]+$/.test(start) || !/^[-+]?[0-9]+$/.test(deleteCount):
                        break
                    case obj.length >= 0:
                        end = obj.length === 0 ? 0 : obj.length - 1
                        start = obj.length <= Math.abs(start) ? (deleteCount === 0 ? obj.length : end) : (start < 0 ? end + start : start)
                        deleteCount = deleteCount === 0 ? (
                            args = exports.slice(arguments, 3),
                            deleteCount) : (obj.length - start < deleteCount ? obj.length - start : deleteCount)
                        switch (true) {
                            case Array.isArray(obj):
                                result = Array.prototype.splice.apply(obj, args ? [start, deleteCount].concat(args) : [start, deleteCount])
                                break
                            default:
                                if (!args) {
                                    for (let i = start; i < start + deleteCount; i++) {
                                        (result.push(obj[i]), delete obj[i], obj.length--)
                                    }
                                } else {
                                    deleteCount = args.length
                                    for (let i = start, j = 0; i < start + deleteCount; i++, j++) {
                                        (obj.hasOwnProperty(i) ? obj[i + deleteCount - start] = obj[i] : null, obj[i] = args[j], obj.length++)
                                    }
                                }
                        }
                        break
                }

                return result
            }
        },
        /**
         * @name        observe
         * @function
         * @static
         * @public
         * @desc        obj parameter로 전달된 데이터를 감시한다.
         * @param       {Array|ArrayLikeObject}     obj             - 전달된 obj를 감시. 접근 또는 변경될 때마다 listener에 세팅된 hook 함수 호출
         * @param       {Object}                    listeners       - event hook
         * @param       {(Array|ArrayLikeObject)=}  thisArg         - event hook이 호출될 때 this에 바인딩 될 reference
         * @return      {Array|Function}            obj
         * @since       0.0.1
         * @date        2019-02-25
         * @see         {@link https://en.wikipedia.org/wiki/Currying Currying}
        */
        observe: {
            enumerable: true,
            value: (obj, listeners, thisArg) => {
                obj && typeof obj === 'object' && listeners && typeof listeners === 'object' ? (exports.forEach(listeners, function (v) {
                    typeof v === 'function' ? v.bind(thisArg) : null
                }), _observe(obj)) : null
                return obj

                function _observe (target) {
                    switch (true) {
                        case !target || typeof target !== 'object':
                            break
                        case Array.isArray(target):
                            _arrayOb(target)
                            break
                        case target instanceof Map:
                            _objectOb(target)
                            break
                        case typeof target === 'object':
                            exports.forEach(target, (v, k, target) => {
                                switch (true) {
                                    case Array.isArray(v):
                                        _arrayOb(v, k)
                                        _objectOb(target, k)
                                        break
                                    case v instanceof Map:
                                        _mapOb(v, k)
                                        _objectOb(target, k)
                                        break
                                    case typeof v === 'object':
                                        _objectOb(target, k)
                                        _observe(v)
                                        break
                                    default:
                                        _objectOb(target, k)
                                }
                            })
                            break
                    }
                }

                function _objectOb (target, attrName) {
                    target['_' + attrName] = target[attrName]

                    Object.defineProperty(target, attrName, {
                        get: () => {
                            typeof listeners.get === 'function' && listeners.get({
                                data: target['_' + attrName],
                                attrName: attrName,
                                target: target,
                                obj: obj
                            })

                            return target['_' + attrName]
                        },
                        set: (data) => {
                            this['_' + attrName] = data

                            typeof listeners.set === 'function' && listeners.set({
                                data: target['_' + attrName],
                                attrName: attrName,
                                target: target,
                                obj: obj
                            })

                            Array.isArray(data) && _arrayOb(data, attrName)
                        }
                    })
                }

                function _callEmpty () {
                    typeof listeners.empty === 'function' && listeners.empty({
                        attrName: attrName,
                        target: target,
                        obj: obj
                    })
                }

                function _arrayOb (target, attrName) {
                    target._push = target.push
                    target._pop = target.pop
                    target._shift = target.shift
                    target._unshift = target.unshift
                    target._splice = target.splice

                    Object.defineProperties(target, {
                        push: {
                            value: function (data) {
                                let result = this._push(data)

                                typeof listeners.push === 'function' && listeners.push({
                                    data: data,
                                    attrName: attrName,
                                    inidex: this.length - 1,
                                    target: target,
                                    obj: obj
                                })

                                return result
                            }
                        },
                        pop: {
                            value: function () {
                                let _data = this._pop()

                                _data !== undefined && typeof listeners.pop === 'function' && listeners.pop({
                                    data: _data,
                                    attrName: attrName,
                                    index: this.length,
                                    target: target,
                                    obj: obj
                                })

                                this.length === 0 && _callEmpty()

                                return _data
                            }
                        },
                        shift: {
                            value: function () {
                                let _data = this._shift()

                                _data !== undefined && typeof listeners.shift === 'function' && listeners.shift({
                                    data: _data,
                                    attrName: attrName,
                                    index: 0,
                                    target: target,
                                    obj: obj
                                })

                                this.length === 0 ? _callEmpty() : null

                                return _data
                            }
                        },
                        unshift: {
                            value: function (data) {
                                let result = this._unshift(data)

                                typeof listeners.unshift === 'function' && listeners.unshift({
                                    data: data,
                                    attrName: attrName,
                                    index: 0,
                                    target: target,
                                    obj: obj
                                })

                                return result
                            }
                        },
                        splice: {
                            value: function (start, deleteCount) {
                                let result = Array.prototype.splice.apply(target, arguments)

                                typeof listeners.splice === 'function' && listeners.splice({
                                    data: deleteCount === 0 ? {
                                        type: 'add',
                                        start: start,
                                        datas: slice(arguments, 2)
                                    } : {
                                        type: 'del',
                                        start: start,
                                        datas: result
                                    },
                                    attrName: attrName,
                                    target: target,
                                    obj: obj
                                })

                                this.length === 0 && _callEmpty()

                                return result
                            }
                        }
                    })
                }

                function _mapOb (target, attrName) {
                    target._get = target.get
                    target._set = target.set
                    target._clear = target.clear
                    target._delete = target.delete

                    Object.defineProperties(target, {
                        get: {
                            value: function (key) {
                                let value = this._get(key)

                                value !== undefined && typeof listeners.mapGet === 'function' && listeners.mapGet({
                                    data: {
                                        key: key,
                                        value: value
                                    },
                                    attrName: attrName,
                                    target: target,
                                    obj: obj
                                })

                                return value
                            }
                        },
                        set: {
                            value: function (key, value) {
                                this._set(key, value)

                                typeof listeners.mapSet === 'function' && listeners.mapSet({
                                    data: {
                                        key: key,
                                        value: value
                                    },
                                    attrName: attrName,
                                    target: target,
                                    obj: obj
                                })

                                return value
                            }
                        },
                        clear: {
                            value: function () {
                                let result, datas = toArray(target)

                                (result = this._clear()) && typeof listeners.mapClear === 'function' && listeners.mapClear({
                                    data: datas,
                                    attrName: attrName,
                                    target: target,
                                    obj: obj
                                })

                                return result
                            }
                        },
                        delete: {
                            value: function (key) {
                                let result, value = this._get(key)

                                (result = this._delete(key)) && typeof listeners.mapDelete === 'function' && listeners.mapDelete({
                                    data: {
                                        key: key,
                                        value: value
                                    },
                                    attrName: attrName,
                                    target: target,
                                    obj: obj
                                })

                                this.size === 0 && _callEmpty()

                                return result
                            }
                        }
                    })
                }
            }
        },
        /**
         * @name        curry
         * @function
         * @static
         * @public
         * @desc        obj parameter로 전달된 배열 또는 Array Like Object의 element를 삭제 또는 추가<br/>
         *              function을 전달인자로 받으면 curried fucntion을 리턴<br/>
         * @param       {Function}      fn          - 변경할 대상. 함수 타입이 전달되면 curried function 리턴
         * @param       {(...any)=}     ...params   - 변경을 시작할 index<br/>
         * @return      {Function}      curried function<br/>
         * @since       0.0.1
         * @date        2019-02-25
         * @see         {@link https://en.wikipedia.org/wiki/Currying Currying}
        */
        curry: {
            enumerable: true,
            value: function () {
                let _curryArgs = exports.toArray(arguments),
                    _isExistMarker = exports.some(_curryArgs, v => v === exports.$_MARKER),
                    _fn = _curryArgs.shift()

                return function () {
                    let _cArgs = exports.toArray(arguments)

                    return typeof _fn === 'function' ? _fn.apply(null, (_isExistMarker ? exports.map(
                        _curryArgs,
                        (v, k, _curryArgs) => v === exports.$_MARKER ? _cArgs.shift() : v) : _curryArgs).concat(_cArgs)) : _fn
                }
            }
        },
        /**
         * @name        curryR
         * @function
         * @static
         * @public
         * @desc        obj parameter로 전달된 배열 또는 Array Like Object의 element를 삭제 또는 추가<br/>
         *              function을 전달인자로 받으면 curried fucntion을 리턴<br/>
         * @param       {Function}      fn          - 변경할 대상. 함수 타입이 전달되면 curried function 리턴
         * @param       {(...any)=}     ...params   - 변경을 시작할 index<br/>
         * @return      {Function}      curried function<br/>
         * @since       0.0.1
         * @date        2019-02-25
         * @see         {@link https://en.wikipedia.org/wiki/Currying Currying}
        */
        curryR: {
            enumerable: true,
            value: function () {
                let _curryArgs = exports.toArray(arguments),
                    _markerIndexes = exports.filter(_curryArgs, v => v === exports.$_MARKER, (v, k) => k - 1).reverse(),
                    _isExistMarker = _markerIndexes.length > 0,
                    _fn = _curryArgs.shift()

                return function () {
                    let _cArgs = exports.toArray(arguments)

                    return typeof _fn === 'function' ? _fn.apply(null, _cArgs.concat(_isExistMarker ? (exports.map(
                        _markerIndexes,
                        v => _curryArgs[v] === exports.$_MARKER ? _cArgs.pop() : v), _curryArgs) : _curryArgs)) : _fn
                }
            }
        },
        /**
         * @name        pipe
         * @function
         * @static
         * @public
         * @desc        obj parameter로 전달된 배열 또는 Array Like Object의 element를 삭제 또는 추가<br/>
         *              function을 전달인자로 받으면 curried fucntion을 리턴<br/>
         * @param       {Array|ArrayLikeObject}     obj             - 변경할 대상. 함수 타입이 전달되면 curried function 리턴
         * @param       {Array|ArrayLikeObject}     start           - 변경을 시작할 index<br/>
         *                                                            obj의 길이보다 큰 값이라면 실제 시작 인덱스는 배열의 길이로 설정<br/>
         *                                                            음수인 경우 obj의 끝에서부터 index 계산
         * @param       {(Array|ArrayLikeObject)=}  deleteCount     - 제거할 element의 수<br/>
         *                                                            deleteCount를 생략하거나 값이 array.length - start보다 크면 start부터의 모든 요소를 제거<br/>
         *                                                            deleteCount가 0 이하라면 items로 전달된 데이터들을 obj에 추가
         * @param       {...Object=}                ...items
         * @return      {Array|Function}            obj<br/>
         *                                          obj가 function인 경우 carried function 리턴
         * @since       0.0.1
         * @date        2019-02-25
         * @see         {@link https://en.wikipedia.org/wiki/Currying Currying}
         * @see         {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/splice Array.prototype.splice}
        */
        pipe: {
            enumerable: true,
            value: function () {
                let fns = exports.filter(Array.isArray(arguments[0]) ? arguments[0] : arguments, fn => typeof fn === 'function')

                return function (arg) {
                    return exports.reduce(fns, (arg, fn) => arg instanceof Promise ? arg.then(fn) : fn(arg), arg)
                }
            }
        },
        /**
         * @name        go
         * @function
         * @static
         * @public
         * @desc        obj parameter로 전달된 배열 또는 Array Like Object의 element를 삭제 또는 추가<br/>
         *              function을 전달인자로 받으면 curried fucntion을 리턴<br/>
         * @param       {Array|ArrayLikeObject}     obj             - 변경할 대상. 함수 타입이 전달되면 curried function 리턴
         * @param       {Array|ArrayLikeObject}     start           - 변경을 시작할 index<br/>
         *                                                            obj의 길이보다 큰 값이라면 실제 시작 인덱스는 배열의 길이로 설정<br/>
         *                                                            음수인 경우 obj의 끝에서부터 index 계산
         * @param       {(Array|ArrayLikeObject)=}  deleteCount     - 제거할 element의 수<br/>
         *                                                            deleteCount를 생략하거나 값이 array.length - start보다 크면 start부터의 모든 요소를 제거<br/>
         *                                                            deleteCount가 0 이하라면 items로 전달된 데이터들을 obj에 추가
         * @param       {...Object=}                ...items
         * @return      {Array|Function}            obj<br/>
         *                                          obj가 function인 경우 carried function 리턴
         * @since       0.0.1
         * @date        2019-02-25
         * @see         {@link https://en.wikipedia.org/wiki/Currying Currying}
         * @see         {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/splice Array.prototype.splice}
        */
        go: {
            enumerable: true,
            value: function (arg) {
                return exports.pipe.apply(null, exports.slice(arguments, 1))(arg)
            }
        },
        /**
         * @name        clone
         * @function
         * @static
         * @public
         * @desc        obj parameter로 전달된 객체를 복사하여 리턴한다
         * @param       {Object}    obj     - 복사할 대상
         * @return      {Object}    복사된 obj
         * @since       0.0.1
         * @date        2019-02-25
        */
        clone: {
            enumerable: true,
            value: function (obj) {
                return obj && typeof obj === 'object' ? JSON.parse(JSON.stringify(obj)) : obj;
            }
        },
        /**
         * @name        debounce
         * @function
         * @static
         * @public
         * @desc        debounse 된 함수가 호출된 후 interval 시간 후에 가장 마지막에 호출된 함수가 호출된다.<br/>
         *              immediate가 true면 맨 처음 호출된 함수가 interval 시간 후 호출된다.
         * @param       {Function}      fn                  - 변경할 대상. 함수 타입이 전달되면 curried function 리턴
         * @param       {Number=}       [interval=1000]     - 변경을 시작할 index<br/>
         * @param       {Boolean}       [immediate=false]   - 제거할 element의 수<br/>
         * @return      {Function}      obj<br/>
         * @since       0.0.1
         * @date        2019-02-25
         * @see         {@link https://en.wikipedia.org/wiki/Currying Currying}
         * @see         {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/splice Array.prototype.splice}
        */
        debounce: {
            enumerable: true,
            value: function (fn, interval, immediate) {
                let timer, isLock = false, action

                typeof interval !== 'number' && (interval = 1000)

                action = immediate ? (...args) => (
                    isLock ? null : (
                        isLock = true,
                        fn.apply(null, args)),
                    clearTimeout(timer),
                    timer = setTimeout(() => (isLock = false), interval)
                ) : (...args) => (
                    clearTimeout(timer),
                    timer = setTimeout(fn, interval, ...args))

                return function (...args) {
                    action(...args)
                }
            }
        },
        /**
         * @name        throttle
         * @function
         * @static
         * @public
         * @desc        throttle 된 함수가 호출된 후 waitTime 시간 동안 호출된 함수는 실행되지 않는다.<br/>
         *              함수 연속 호출 시, waitTime 시간 후에 마지막 호출된 함수가 호출된다.<br/>
         *              option.leading이 false면 함수 연속 호출 시, 최초 호출된 함수는 호출되지 않는다.<br/>
         *              option.trailing이 false면 마지막 호출된 함수는 호출되지 않는다.
         * @param       {Array|ArrayLikeObject}     obj             - 변경할 대상. 함수 타입이 전달되면 curried function 리턴
         * @param       {Array|ArrayLikeObject}     start           - 변경을 시작할 index<br/>
         *                                                            obj의 길이보다 큰 값이라면 실제 시작 인덱스는 배열의 길이로 설정<br/>
         *                                                            음수인 경우 obj의 끝에서부터 index 계산
         * @param       {(Array|ArrayLikeObject)=}  deleteCount     - 제거할 element의 수<br/>
         *                                                            deleteCount를 생략하거나 값이 array.length - start보다 크면 start부터의 모든 요소를 제거<br/>
         *                                                            deleteCount가 0 이하라면 items로 전달된 데이터들을 obj에 추가
         * @param       {...Object=}                ...items
         * @return      {Array|Function}            obj<br/>
         *                                          obj가 function인 경우 carried function 리턴
         * @since       0.0.1
         * @date        2019-02-25
         * @see         {@link https://en.wikipedia.org/wiki/Currying Currying}
         * @see         {@link https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/splice Array.prototype.splice}
        */
        throttle: {
            enumerable: true,
            value: function (fn, waitTime, option) {
                let isLock = false, leading = true, trailing = true, trailArgs, callback, timer

                typeof waitTime !== 'number' && (waitTime = 1000)

                if (option && typeof option === 'object') {
                    typeof option.leading === 'boolean' && (leading = option.leading)
                    typeof option.trailing === 'boolean' && (trailing = option.trailing)
                }

                return function _throttledFn (...args) {
                    let temp;
                    isLock ? (trailing ? trailArgs = args : null) : (
                        isLock = true,
                        leading ? fn(...args) : null,
                        setTimeout(
                            () => (
                                isLock = false,
                                trailArgs ? (
                                    temp = trailArgs,
                                    trailArgs = null,
                                    fn(...temp)) : null),
                            //_throttledFn(...temp)) : null),
                            waitTime))
                }
            }
        }
    })
